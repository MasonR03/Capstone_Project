name: Build and Deploy

on:
  push:
    branches:
      - main


env:
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/capstone-project
  CONTAINER_NAME: capstone-app
  HOST_PORT: 8082
  CONTAINER_PORT: 8082

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.IMAGE_NAME }}:latest

  deploy:
    name: Deploy to EC2
    needs: build-and-push
    runs-on: self-hosted
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        run: echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Pull and start stack (app + db)
        env:
          APP_IMAGE: ${{ env.IMAGE_NAME }}:${{ github.sha }}
          HOST_PORT: ${{ env.HOST_PORT }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          docker pull ${{ env.IMAGE_NAME }}:${{ github.sha }}
          INIT_DIR="$HOME/orbitfall/postgres"
          mkdir -p "$INIT_DIR"
          cp -f postgres/init.sql "$INIT_DIR/init.sql"
          export INIT_SQL_PATH="$INIT_DIR/init.sql"

          if docker compose version >/dev/null 2>&1; then
            compose() { docker compose "$@"; }
          else
            compose() { docker-compose "$@"; }
          fi

          # Transition: remove legacy single-container deploy (if present)
          docker rm -f "${{ env.CONTAINER_NAME }}" 2>/dev/null || true

          compose -p "${{ env.CONTAINER_NAME }}" down || true
          compose -p "${{ env.CONTAINER_NAME }}" up -d --no-build

          compose -p "${{ env.CONTAINER_NAME }}" ps

          DB_CID="$(compose -p "${{ env.CONTAINER_NAME }}" ps -q db)"
          APP_CID="$(compose -p "${{ env.CONTAINER_NAME }}" ps -q app)"

          if [ -z "$DB_CID" ] || [ -z "$APP_CID" ]; then
            echo "❌ Expected db/app containers were not created."
            compose -p "${{ env.CONTAINER_NAME }}" ps || true
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 || true
            exit 1
          fi

          echo "⏳ Waiting for db to become healthy..."
          for i in $(seq 1 60); do
            health="$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$DB_CID" 2>/dev/null || echo unknown)"
            if [ "$health" = "healthy" ]; then
              echo "✅ db is healthy"
              break
            fi
            if [ "$health" = "unhealthy" ]; then
              echo "❌ db is unhealthy"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
              exit 1
            fi
            sleep 2
          done

          health="$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$DB_CID" 2>/dev/null || echo unknown)"
          if [ "$health" != "healthy" ]; then
            echo "❌ Timed out waiting for db health (status: $health)"
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
            exit 1
          fi

          echo "⏳ Waiting for app to be running..."
          for i in $(seq 1 30); do
            status="$(docker inspect -f '{{.State.Status}}' "$APP_CID" 2>/dev/null || echo missing)"
            if [ "$status" = "running" ]; then
              echo "✅ app is running"
              break
            fi
            if [ "$status" = "exited" ] || [ "$status" = "dead" ]; then
              echo "❌ app is not running (status: $status)"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
              exit 1
            fi
            sleep 2
          done

          status="$(docker inspect -f '{{.State.Status}}' "$APP_CID" 2>/dev/null || echo missing)"
          if [ "$status" != "running" ]; then
            echo "❌ Timed out waiting for app to be running (status: $status)"
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
            exit 1
          fi

          echo "⏳ Waiting for Prisma to connect to the database..."
          for i in $(seq 1 60); do
            if docker logs "$APP_CID" 2>/dev/null | grep -q "✅ Database connected (Prisma)"; then
              echo "✅ Prisma connected"
              exit 0
            fi
            if docker logs "$APP_CID" 2>/dev/null | grep -q "Database connection failed"; then
              echo "❌ Prisma reported a DB connection failure"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
              exit 1
            fi
            sleep 2
          done

          echo "❌ Timed out waiting for Prisma to connect"
          compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
          compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
          exit 1
