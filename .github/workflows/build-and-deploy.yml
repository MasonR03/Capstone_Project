name: Build and Deploy

on:
  push:
    branches:
      - main


env:
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/capstone-project
  CONTAINER_NAME: capstone-app
  HOST_PORT: 8082
  CONTAINER_PORT: 8082

jobs:
  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
            ${{ env.IMAGE_NAME }}:latest

  deploy:
    name: Deploy to EC2
    needs: build-and-push
    runs-on: self-hosted
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        run: echo ${{ secrets.DOCKERHUB_TOKEN }} | docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin

      - name: Pull and start stack (app + db)
        env:
          APP_IMAGE: ${{ env.IMAGE_NAME }}:${{ github.sha }}
          HOST_PORT: ${{ env.HOST_PORT }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
          RESET_DB_ON_REBOOT: ${{ vars.RESET_DB_ON_REBOOT }}
        run: |
          docker pull ${{ env.IMAGE_NAME }}:${{ github.sha }}
          ORBITFALL_DIR="$HOME/orbitfall"
          export ORBITFALL_DIR
          mkdir -p "$ORBITFALL_DIR/postgres"

          cp -f docker-compose.yml "$ORBITFALL_DIR/docker-compose.yml"
          cp -f postgres/init.sql "$ORBITFALL_DIR/postgres/init.sql"
          cp -f scripts/reset-db-on-reboot.sh "$ORBITFALL_DIR/reset-db-on-reboot.sh"
          chmod +x "$ORBITFALL_DIR/reset-db-on-reboot.sh"

          # Compose reads `.env` automatically from the working directory.
          cat > "$ORBITFALL_DIR/.env" <<EOF
          APP_IMAGE=$APP_IMAGE
          HOST_PORT=$HOST_PORT
          POSTGRES_PASSWORD=$POSTGRES_PASSWORD
          INIT_SQL_PATH=$ORBITFALL_DIR/postgres/init.sql
          EOF

          cd "$ORBITFALL_DIR"

          if docker compose version >/dev/null 2>&1; then
            compose() { docker compose "$@"; }
          else
            compose() { docker-compose "$@"; }
          fi

          # Transition: remove legacy single-container deploy (if present)
          docker rm -f "${{ env.CONTAINER_NAME }}" 2>/dev/null || true

          compose -p "${{ env.CONTAINER_NAME }}" down || true
          compose -p "${{ env.CONTAINER_NAME }}" up -d --no-build

          # Optional: wipe DB on host reboot (ephemeral environments only).
          if [ "${RESET_DB_ON_REBOOT:-0}" = "1" ]; then
            echo "üîÅ Installing @reboot DB reset cron (this wipes all player stats on reboot)"
            CRON_LINE="@reboot ORBITFALL_DIR=$ORBITFALL_DIR $ORBITFALL_DIR/reset-db-on-reboot.sh ${{ env.CONTAINER_NAME }} >> $ORBITFALL_DIR/reboot-reset.log 2>&1"
            (crontab -l 2>/dev/null | grep -v "reset-db-on-reboot.sh" || true; echo "$CRON_LINE") | crontab -
          else
            echo "‚ÑπÔ∏è RESET_DB_ON_REBOOT not enabled; leaving DB persistent across reboots."
          fi

          compose -p "${{ env.CONTAINER_NAME }}" ps

          DB_CID="$(compose -p "${{ env.CONTAINER_NAME }}" ps -q db)"
          APP_CID="$(compose -p "${{ env.CONTAINER_NAME }}" ps -q app)"

          if [ -z "$DB_CID" ] || [ -z "$APP_CID" ]; then
            echo "‚ùå Expected db/app containers were not created."
            compose -p "${{ env.CONTAINER_NAME }}" ps || true
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 || true
            exit 1
          fi

          echo "‚è≥ Waiting for db to become healthy..."
          for i in $(seq 1 60); do
            health="$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$DB_CID" 2>/dev/null || echo unknown)"
            if [ "$health" = "healthy" ]; then
              echo "‚úÖ db is healthy"
              break
            fi
            if [ "$health" = "unhealthy" ]; then
              echo "‚ùå db is unhealthy"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
              exit 1
            fi
            sleep 2
          done

          health="$(docker inspect -f '{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$DB_CID" 2>/dev/null || echo unknown)"
          if [ "$health" != "healthy" ]; then
            echo "‚ùå Timed out waiting for db health (status: $health)"
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
            exit 1
          fi

          echo "‚è≥ Waiting for app to be running..."
          for i in $(seq 1 30); do
            status="$(docker inspect -f '{{.State.Status}}' "$APP_CID" 2>/dev/null || echo missing)"
            if [ "$status" = "running" ]; then
              echo "‚úÖ app is running"
              break
            fi
            if [ "$status" = "exited" ] || [ "$status" = "dead" ]; then
              echo "‚ùå app is not running (status: $status)"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
              exit 1
            fi
            sleep 2
          done

          status="$(docker inspect -f '{{.State.Status}}' "$APP_CID" 2>/dev/null || echo missing)"
          if [ "$status" != "running" ]; then
            echo "‚ùå Timed out waiting for app to be running (status: $status)"
            compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
            exit 1
          fi

          echo "‚è≥ Waiting for Prisma to connect to the database..."
          for i in $(seq 1 60); do
            if docker logs "$APP_CID" 2>/dev/null | grep -q "‚úÖ Database connected (Prisma)"; then
              echo "‚úÖ Prisma connected"
              exit 0
            fi
            if docker logs "$APP_CID" 2>/dev/null | grep -q "Database connection failed"; then
              echo "‚ùå Prisma reported a DB connection failure"
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
              compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
              exit 1
            fi
            sleep 2
          done

          echo "‚ùå Timed out waiting for Prisma to connect"
          compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 app || true
          compose -p "${{ env.CONTAINER_NAME }}" logs --tail 200 db || true
          exit 1
